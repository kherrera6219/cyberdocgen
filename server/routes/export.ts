import { Router } from 'express';
import OpenAI from 'openai';
import { logger } from '../utils/logger';
import { storage } from '../storage';
import { isAuthenticated } from '../replitAuth';
import { validateBody } from '../middleware/routeValidation';
import {
  exportDocumentRequestSchema,
  saveDocumentRequestSchema,
  generateDocumentRequestSchema
} from '../validation/requestSchemas';

function getContentType(format: string): string {
  const contentTypes: Record<string, string> = {
    'pdf': 'application/pdf',
    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'txt': 'text/plain',
    'html': 'text/html',
    'json': 'application/json'
  };
  return contentTypes[format.toLowerCase()] || 'application/octet-stream';
}

export function registerExportRoutes(router: Router) {
  router.post('/export-document', isAuthenticated, validateBody(exportDocumentRequestSchema), async (req: any, res) => {
    try {
      const { content, format, filename } = req.body;

      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const exportFilename = filename || `document-${timestamp}.${format}`;
      
      res.setHeader('Content-Type', getContentType(format));
      res.setHeader('Content-Disposition', `attachment; filename="${exportFilename}"`);

      if (format.toLowerCase() === 'html') {
        const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <title>${filename || 'Compliance Document'}</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
        h1, h2, h3 { color: #333; }
        h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
        .header { text-align: center; margin-bottom: 40px; }
        .footer { margin-top: 40px; font-size: 0.9em; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${filename || 'Compliance Document'}</h1>
        <p>Generated on ${new Date().toLocaleDateString()}</p>
    </div>
    <div class="content">
        ${content.replace(/\n/g, '<br>').replace(/#{1,6}\s(.+)/g, '<h3>$1</h3>')}
    </div>
    <div class="footer">
        <p>Generated by ComplianceAI Platform</p>
    </div>
</body>
</html>`;
        res.send(htmlContent);
      } else {
        res.send(content);
      }

    } catch (error: any) {
      logger.error("Document export failed", { error: error.message, format: req.body.format });
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  router.post('/save-document', isAuthenticated, validateBody(saveDocumentRequestSchema), async (req: any, res) => {
    try {
      const { title, content, framework, category, companyProfileId, createdBy } = req.body;

      let finalCompanyProfileId = companyProfileId;
      
      if (!finalCompanyProfileId) {
        let systemUserId = createdBy;
        if (!systemUserId || systemUserId === 'system') {
          let systemUser = await storage.getUserByEmail('system@compliance.ai');
          if (!systemUser) {
            systemUser = await storage.createUser({
              email: 'system@compliance.ai',
              firstName: 'System',
              lastName: 'Generated'
            });
          }
          systemUserId = systemUser.id;
        }
        
        const systemProfile = await storage.createCompanyProfile({
          organizationId: 'system-org',
          companyName: 'System Generated',
          industry: 'General',
          companySize: 'Small',
          headquarters: 'N/A',
          dataClassification: 'internal',
          businessApplications: 'Auto-generated profile for standalone documents',
          createdBy: systemUserId
        });
        finalCompanyProfileId = systemProfile.id;
      }

      const documentData = {
        title,
        content,
        framework,
        category: category || 'general',
        status: 'draft' as const,
        companyProfileId: finalCompanyProfileId,
        createdBy: createdBy || 'system'
      };

      const savedDocument = await storage.createDocument(documentData);
      
      res.json({
        success: true,
        document: savedDocument
      });

    } catch (error: any) {
      logger.error("Document save failed", { error: error.message, title: req.body.title });
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });

  router.post('/generate-document', isAuthenticated, validateBody(generateDocumentRequestSchema), async (req: any, res) => {
    try {
      const { framework, companyProfile, documentType, templateId, variables } = req.body;
      
      const { DocumentTemplateService } = await import('../services/documentTemplates');
      
      if (templateId && variables) {
        const result = DocumentTemplateService.generateDocument(templateId, variables);
        
        if (!result.success) {
          return res.status(400).json({
            success: false,
            error: 'Template validation failed',
            details: result.errors
          });
        }

        DocumentTemplateService.logTemplateUsage(templateId, framework);

        return res.json({
          success: true,
          framework,
          documentType,
          content: result.content,
          templateBased: true,
          templateId
        });
      }
      
      const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
      
      const systemPrompt = `You are a cybersecurity compliance expert. Generate a comprehensive ${documentType} document for ${framework} compliance framework for the company: ${companyProfile.name} (Industry: ${companyProfile.industry}, Size: ${companyProfile.size}).

Create a professional, enterprise-ready document that meets the latest 2025 compliance standards. Include:
1. Executive Summary
2. Purpose and Scope
3. Policy/Procedure Statements
4. Roles and Responsibilities
5. Implementation Guidelines
6. Technical Controls
7. Compliance Requirements
8. Monitoring and Review
9. Training Requirements
10. Related Documents

Format with clear headings, numbered sections, and actionable guidance.`;
      
      const response = await openai.chat.completions.create({
        model: "gpt-5.1",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: `Generate a detailed ${documentType} document for ${framework} compliance.` }
        ],
        max_completion_tokens: 3000,
      });

      res.json({
        success: true,
        framework,
        documentType,
        content: response.choices[0].message.content,
        templateBased: false,
        model: "gpt-5.1",
        usage: response.usage
      });
    } catch (error: any) {
      logger.error("Document generation failed", { error: error.message, framework: req.body.framework, documentType: req.body.documentType });
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  });
}

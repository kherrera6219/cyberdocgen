import { Router, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';
import { storage } from '../storage';
import { isAuthenticated, getRequiredUserId } from '../replitAuth';
import {
  exportDocumentRequestSchema,
  saveDocumentRequestSchema,
  generateDocumentRequestSchema
} from '../validation/requestSchemas';
import { 
  secureHandler,
  validateInput,
  AppError,
  NotFoundError
} from '../utils/errorHandling';
import { 
  type MultiTenantRequest, 
  requireOrganization,
  getCompanyProfileWithOrgCheck 
} from '../middleware/multiTenant';
import { promptTemplateRegistry } from '../services/promptTemplateRegistry';
import { aiUsageAccountingService } from '../services/aiUsageAccountingService';
import { aiOutputClassificationService } from '../services/aiOutputClassificationService';
import { aiMetadataAuditService } from '../services/aiMetadataAuditService';
import { modelRoutingPolicyService } from '../services/modelRoutingPolicyService';

function getContentType(format: string): string {
  const contentTypes: Record<string, string> = {
    'pdf': 'application/pdf',
    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'txt': 'text/plain',
    'html': 'text/html',
    'json': 'application/json',
    'md': 'text/markdown'
  };
  return contentTypes[format.toLowerCase()] || 'application/octet-stream';
}

export function registerExportRoutes(router: Router) {
  /**
   * Export document (public - users can export any content they provide)
   */
  router.post('/export-document', validateInput(exportDocumentRequestSchema), secureHandler(async (req: MultiTenantRequest, res: Response, _next: NextFunction) => {
    const { content, format, filename } = req.body;

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const exportFilename = filename || `document-${timestamp}.${format}`;
    
    res.setHeader('Content-Type', getContentType(format));
    res.setHeader('Content-Disposition', `attachment; filename="${exportFilename}"`);

    if (format.toLowerCase() === 'html') {
      const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <title>${filename || 'Compliance Document'}</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
        h1, h2, h3 { color: #333; }
        h1 { border-bottom: 2px solid #333; padding-bottom: 10px; }
        .header { text-align: center; margin-bottom: 40px; }
        .footer { margin-top: 40px; font-size: 0.9em; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${filename || 'Compliance Document'}</h1>
        <p>Generated on ${new Date().toLocaleDateString()}</p>
    </div>
    <div class="content">
        ${content.replace(/\n/g, '<br>').replace(/#{1,6}\s(.+)/g, '<h3>$1</h3>')}
    </div>
    <div class="footer">
        <p>Generated by ComplianceAI Platform</p>
    </div>
</body>
</html>`;
      res.send(htmlContent);
    } else {
      res.send(content);
    }
  }));

  /**
   * Save document to storage
   */
  router.post('/save-document', isAuthenticated, requireOrganization, validateInput(saveDocumentRequestSchema), secureHandler(async (req: MultiTenantRequest, res: Response, _next: NextFunction) => {
    const { title, content, framework, category, companyProfileId, createdBy } = req.body;
    const organizationId = req.organizationId!;
    const userId = getRequiredUserId(req);

    let finalCompanyProfileId = companyProfileId;
    
    if (!finalCompanyProfileId) {
      // Create a default profile if none provided, but scoped to the user's organization
      const systemProfile = await storage.createCompanyProfile({
        organizationId,
        companyName: 'Company Profile',
        industry: 'General',
        companySize: 'Small',
        headquarters: 'N/A',
        dataClassification: 'internal',
        businessApplications: 'Auto-generated profile for standalone documents',
        createdBy: userId
      });
      finalCompanyProfileId = systemProfile.id;
    } else {
      // Validate that the provided company profile belongs to the organization
      const { authorized } = await getCompanyProfileWithOrgCheck(finalCompanyProfileId, organizationId);
      if (!authorized) {
        throw new NotFoundError("Company profile not found");
      }
    }

    const documentData = {
      title,
      content,
      framework,
      category: category || 'general',
      status: 'draft' as const,
      companyProfileId: finalCompanyProfileId,
      createdBy: userId,
      organizationId // Ensure document is linked to org
    };

    const savedDocument = await storage.createDocument(documentData);
    
    res.json({
      success: true,
      data: savedDocument
    });
  }, { audit: { action: 'create', entityType: 'document' } }));

  /**
   * Generate document using AI
   */
  router.post('/generate-document', isAuthenticated, requireOrganization, validateInput(generateDocumentRequestSchema), secureHandler(async (req: MultiTenantRequest, res: Response, _next: NextFunction) => {
    const { framework, companyProfile, documentType, templateId, variables } = req.body;
    const userId = getRequiredUserId(req);
    const organizationId = req.organizationId!;
    
    const { DocumentTemplateService } = await import('../services/documentTemplates');
    
    if (templateId && variables) {
      const result = DocumentTemplateService.generateDocument(templateId, variables);
      
      if (!result.success) {
        throw new AppError('Template validation failed', 400, 'TEMPLATE_ERROR', result.errors);
      }

      DocumentTemplateService.logTemplateUsage(templateId, framework);

      res.json({
        success: true,
        data: {
          framework,
          documentType,
          content: result.content,
          templateBased: true,
          templateId
        }
      });
      return;
    }
    
    const { getOpenAIClient } = await import('../services/aiClients');
    const openai = getOpenAIClient();
    const routingDecision = modelRoutingPolicyService.route({
      requestedModel: 'auto',
      operation: 'export_generation',
      framework,
      templateCategory: documentType,
    });
    const selectedModel = routingDecision.selectedModel;
    const promptTemplate = promptTemplateRegistry.renderTemplate('export_generation', {
      framework,
      documentType,
    });
    const budgetCheck = await aiUsageAccountingService.checkBudget({
      userId,
      organizationId,
      actionType: 'export_generation',
      model: selectedModel,
      prompt: promptTemplate.prompt,
      expectedResponseTokens: 3000,
    });
    if (!budgetCheck.allowed) {
      throw new AppError('AI usage budget exceeded for this organization', 429, 'AI_BUDGET_EXCEEDED', {
        reason: budgetCheck.reason,
      });
    }
    
    const systemPrompt = `You are a cybersecurity compliance expert. Generate a comprehensive ${documentType} document for ${framework} compliance framework for the company: ${companyProfile.name} (Industry: ${companyProfile.industry}, Size: ${companyProfile.size}).

Create a professional, enterprise-ready document that meets the latest 2025 compliance standards. Include:
1. Executive Summary
2. Purpose and Scope
3. Policy/Procedure Statements
4. Roles and Responsibilities
5. Implementation Guidelines
6. Technical Controls
7. Compliance Requirements
8. Monitoring and Review
9. Training Requirements
10. Related Documents

Format with clear headings, numbered sections, and actionable guidance.`;
    
    const response = await openai.chat.completions.create({
      model: "gpt-5.1",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: `Generate a detailed ${documentType} document for ${framework} compliance.` }
      ],
      max_completion_tokens: 3000,
    });
    const generatedContent = response.choices[0].message.content || "";
    const outputClassification = aiOutputClassificationService.classify(generatedContent);
    const governanceUsage = await aiUsageAccountingService.recordUsage({
      userId,
      organizationId,
      actionType: 'export_generation',
      model: selectedModel,
      prompt: `${systemPrompt}\n\nGenerate a detailed ${documentType} document for ${framework} compliance.`,
      response: generatedContent,
      purposeDescription: `Generate export-ready ${documentType} for ${framework}`,
      dataUsed: ['company_profile', 'framework'],
      aiContribution: 'full',
      humanOversight: true,
    });
    await aiMetadataAuditService.record({
      actionType: 'export_generation',
      model: selectedModel,
      userId,
      organizationId,
      requestId: (req as any).requestId,
      promptTemplateKey: promptTemplate.key,
      promptTemplateVersion: promptTemplate.version,
      outputClassification,
      usage: governanceUsage,
      metadata: {
        framework,
        documentType,
      },
    });

    res.json({
      success: true,
      data: {
        framework,
        documentType,
        content: generatedContent,
        templateBased: false,
        model: selectedModel,
        usage: response.usage,
        governanceUsage,
      }
    });
  }, { audit: { action: 'create', entityType: 'generatedDocument' } }));
}
